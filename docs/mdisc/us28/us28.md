# US28: 
**As a Product Owner, I want to conclude about the efficiency of
the above procedure, by analysing the worst-case time complexity.**
## Purpose
This document analyzes the computational efficiency of the shortest route feature
implemented in US27.It aims to determine the worst-case time complexity based on 
the algorithm used and its practical implementation.

## Algorithms Used
1. **Multi-Stage Ordered Shortest Path Algorithm**

*This algorithm solves the problem of finding a path through a specific
ordered list of stations by applying the standard Single-Source Shortest
Path algorthm repeatedly between each consecutive pair of stations.
It ensures that each sub-path is optimal and combines them into a single
route.*

```pseudo
function multiStageOrderedShortestPath(graph, requiredStations):
    if requiredStations.size < 2:
        return null

    for each station in requiredStations:
        if station not in graph:
            return null

    fullPath = []
    for i from 0 to requiredStations.size - 2:
        segment = singleSourceShortestPath(graph, requiredStations[i], requiredStations[i+1])
        if segment is null:
            return null

        if i < requiredStations.size - 2:
            fullPath.addAll(segment[0 to segment.size - 2])
        else:
            fullPath.addAll(segment)

    return fullPath
```
**Worst-Case Time Complexity:**

* n = number of stations (vertices)
* m = number of connections (edges)
* k = number of stations in the requiredStations list
* This function calls singleSourceShortestPath (k - 1) times.
* Each singleSourceShortestPath runs in O((n + m) * log n) time.
*Therefore, the total worst-case time complexity is:*
*O(k * (n + m) * log n)*

**Time Complexity Explanation**
Each run of the shortest path algorithm processes:
All vertices once ⇒ O(n log n) using a min-heap
Each edge at most once ⇒ O(m log n) (due to priority queue operations)
A single run = O((n + m) * log n)
Since **orderedMultiSegmentDijkstra** runs the algorithm k - 1 times:
**Total = (k - 1) * O((n + m) * log n) = O(k * (n + m) * log n)**

**2.Single-Source Dijkstra Algorithm**

This is the classical Dijkstra’s algorithm used to compute the shortest 
path from one source station to a destination station. It utilizes a min-heap
(priority queue) to efficiently determine the next closest station to explore.

```pseudo
function singleSourceDijkstra(graph, start, end):
    if start or end not in graph:
        return null

    distances = map with all stations set to infinity
    distances[start] = 0
    predecessors = empty map
    priorityQueue = new MinHeap
    priorityQueue.add(Node(start, 0))

    while priorityQueue is not empty:
        current = priorityQueue.poll()

        if current.station == end:
            break

        if current.distance > distances[current.station]:
            continue

        for each neighbor in graph[current.station]:
            newDistance = current.distance + edge.distance
            if newDistance < distances[neighbor]:
                distances[neighbor] = newDistance
                predecessors[neighbor] = current.station
                priorityQueue.add(Node(neighbor, newDistance))

    path = reconstruct path from predecessors
    return path if start in path else null
```

**Worst-Case Time Complexity**
Dijkstra’s algorithm using a priority queue (min-heap):
**O((n + m) * log n)**

**Analysis Conclusion**
The algorithm handles ordered traversal of a user-specified station list by
executing shortest-path calculations for each egsment.
The number of calculations = number of segments = k - 1, where k is the number of stations.
Each segment is solved using Dijkstra’s algorithm.
**Total Time Complexity:**
O(k * (n + m) * log n)

**Efficient for sparse graphs and short station lists.Complexity grows linearly with the number of required station segments.**
