# US28:
**As a Product Owner, I want to conclude about the efficiency of the above procedure, by analysing the worst-case time complexity.**

## Purpose
This document analyzes the computational efficiency of the shortest route feature implemented in US27. It aims to determine the worst-case time complexity based on the algorithm used and its practical implementation.

## Algorithms Used

### 1. Multi-Stage Ordered Shortest Path Algorithm

*This algorithm solves the problem of finding a path through a specific ordered list of stations by applying the standard Single-Source Shortest Path algorithm repeatedly between each consecutive pair of stations. It ensures that each sub-path is optimal and combines them into a single route.*

```pseudo
function multiStageOrderedShortestPath(graph, requiredStations):
    if requiredStations.size < 2:
        return null

    for each station in requiredStations:
        if station not in graph:
            return null

    fullPath = []
    for i from 0 to requiredStations.size - 2:
        segment = singleSourceShortestPath(graph, requiredStations[i], requiredStations[i+1])
        if segment is null:
            return null

        if i < requiredStations.size - 2:
            fullPath.addAll(segment[0 to segment.size - 2])
        else:
            fullPath.addAll(segment)

    return fullPath
```

### Worst-Case Time Complexity

- $n$: number of stations (vertices)
- $m$: number of connections (edges)
- $k$: number of stations in the requiredStations list
- The function calls Dijkstra $(k - 1)$ times
- Each Dijkstra run = $O((n + m) \log n)$
- **Total Complexity** = $O(k(n + m) \log n)$

---

## Step-by-Step Big O Analysis

| Step | Outer Loop Index $i$ | Station Pair $(s_i, s_{i+1})$ | Call to Dijkstra | Dijkstra Work              | Comparisons | Time per Step              |
|------|----------------------|-------------------------------|------------------|----------------------------|-------------|----------------------------|
| 1    | $i = 0$              | $(s_0, s_1)$                  | Yes              | Visit $n$, check $m$ edges | $m$         | $O((n + m) \log n)$        |
| 2    | $i = 1$              | $(s_1, s_2)$                  | Yes              | Visit $n$, check $m$ edges | $m$         | $O((n + m) \log n)$        |
| 3    | $i = 2$              | $(s_2, s_3)$                  | Yes              | Visit $n$, check $m$ edges | $m$         | $O((n + m) \log n)$        |
| ...  | $\vdots$             | $\vdots$                      | Yes              | $\vdots$                   | $\vdots$    | $\vdots$                   |
| $k-1$| $i = k-2$            | $(s_{k-2}, s_{k-1})$          | Yes              | Visit $n$, check $m$ edges | $m$         | $O((n + m) \log n)$        |

### Total Time Complexity:

$$
T(n, m, k) = (k - 1) \cdot O((n + m) \log n) = O(k(n + m)\log n)
$$

---

### 2. Single-Source Dijkstra Algorithm

*This is the classical Dijkstraâ€™s algorithm used to compute the shortest path from one source station to a destination station. It utilizes a min-heap (priority queue) to efficiently determine the next closest station to explore.*

```pseudo
function singleSourceDijkstra(graph, start, end):
    if start or end not in graph:
        return null

    distances = map with all stations set to infinity
    distances[start] = 0
    predecessors = empty map
    priorityQueue = new MinHeap
    priorityQueue.add(Node(start, 0))

    while priorityQueue is not empty:
        current = priorityQueue.poll()

        if current.station == end:
            break

        if current.distance > distances[current.station]:
            continue

        for each neighbor in graph[current.station]:
            newDistance = current.distance + edge.distance
            if newDistance < distances[neighbor]:
                distances[neighbor] = newDistance
                predecessors[neighbor] = current.station
                priorityQueue.add(Node(neighbor, newDistance))

    path = reconstruct path from predecessors
    return path if start in path else null
```

### Dijkstra's Worst-Case Time Complexity

- Uses priority queue (min-heap):
- Processes all vertices and edges once
- **Time Complexity**: $O((n + m) \log n)$

---

## Analysis Conclusion

The algorithm handles ordered traversal of a user-specified station list by executing shortest-path calculations for each segment.
- Number of segments = $k - 1$
- Each segment is solved using Dijkstra
- **Final Total Complexity**: $O(k(n + m)\log n)$
- Efficient for sparse graphs and short station lists. Complexity grows linearly with the number of required station segments.
